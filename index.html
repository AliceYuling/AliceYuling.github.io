<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Rin&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Rin&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Rin&#39;s blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Rin&#39;s blog">
  
    <link rel="alternate" href="/atom.xml" title="Rin&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Rin&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-浏览器知识总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/15/浏览器知识总结/" class="article-date">
  <time datetime="2020-02-15T11:26:42.000Z" itemprop="datePublished">2020-02-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/15/浏览器知识总结/">浏览器知识总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-浏览器简介"><a href="#1-浏览器简介" class="headerlink" title="1 浏览器简介"></a>1 浏览器简介</h1><p>浏览器也就是用来显示在万维网或局域网等内的文字、图像及其他信息的软件，它还可以让用户与这些文件进行交互操作</p>
<h2 id="1-1-浏览器结构"><a href="#1-1-浏览器结构" class="headerlink" title="1.1 浏览器结构"></a>1.1 浏览器结构</h2><p>1） 用户界面: 主要包括工具栏、地址栏、前进/后退按钮、书签菜单、可视化页面加载进度、智能下载处理、首选项、打印等。<br>2）浏览器内核：通常所谓的浏览器内核也就是浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息<br>内核分类：<br>通用浏览器： Trident（IE）、Gecko（Mozilla Firefox）、Webkit（Safari）、Blink（Chrome28及往后版本、Opera 15及往后版本和Yandex浏览器）<br>专用浏览器： Andriod WebView、iOS WebView、WeChat WebView</p>
<h2 id="1-2-浏览器渲染页面过程"><a href="#1-2-浏览器渲染页面过程" class="headerlink" title="1.2 浏览器渲染页面过程"></a>1.2 浏览器渲染页面过程</h2><p>  1）Html经过HTMLDocumentParser后形成DOM树（Document Object Model）,DOM 中每个元素具有属性, innerText等，DOM是为了让浏览器理解html方便渲染，同时也是给Javascript暴露API接口的一个基本单元</p>
<p>  2）解析css: 通过选择器，根据DOM的结构生成style tree</p>
<p>  3) Layout／reflow: 浏览器计算所有元素的位置、尺寸<br>  4）绘制／repaint：绘制元素像素信息<br>  5）浏览器将各层的信息发送给GPU，GPU将各层合成，显示在屏幕上。</p>
<p>与前端相关的关键渲染路径：<br>让网页尽快加载出来<br>减少浏览器reflow、repaint</p>
<h1 id="2-浏览器本地存储"><a href="#2-浏览器本地存储" class="headerlink" title="2. 浏览器本地存储"></a>2. 浏览器本地存储</h1><h2 id="2-1-Cookie"><a href="#2-1-Cookie" class="headerlink" title="2.1 Cookie"></a>2.1 Cookie</h2><p>Cookie是一小段的文本信息（key-value格式）。客户端向服务器发起请求，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。</p>
<p>Cookie机制</p>
<p>Cookie各项属性值：<br>  Expires： 过期时间<br>  Domain： 生成该 Cookie 的域名<br>  Path： 该 Cookie 是在当前的哪个路径下生成的，如 path=/wp-admin/<br>  Secure： 如果设置了这个属性，那么只会在 SSH 连接时才会回传该 Cookie</p>
<p>Cookie应用场景：带参数，一般不用于存数据</p>
<h2 id="2-2-WebStorage"><a href="#2-2-WebStorage" class="headerlink" title="2.2 WebStorage"></a>2.2 WebStorage</h2><ul>
<li><p>1.sessionStorage：将数据保存在session对象中。所谓session，是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。session对象可以用来保存在这段时间内所要求保存的任何数据。</p>
</li>
<li><p>2.localStorage：将数据保存在客户端本地的硬件设备(通常指硬盘，也可以是其他硬件设备)中，即使浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用。</p>
</li>
</ul>
<h2 id="2-3-IndexedDB-amp-WebSQL"><a href="#2-3-IndexedDB-amp-WebSQL" class="headerlink" title="2.3 IndexedDB &amp; WebSQL"></a>2.3 IndexedDB &amp; WebSQL</h2><p>WebSQL: 已废弃<br>IndexedDB: 可用于一次性把很多数据从后端取到存在前端，后面的计算不用每次请求后端，直接从前端取数据进行计算的场景</p>
<h1 id="3-Web-Worker-amp-Service-Worker"><a href="#3-Web-Worker-amp-Service-Worker" class="headerlink" title="3 Web Worker &amp; Service Worker"></a>3 Web Worker &amp; Service Worker</h1><h2 id="3-1-Web-Worker"><a href="#3-1-Web-Worker" class="headerlink" title="3.1 Web Worker"></a>3.1 Web Worker</h2><p>Web Worker是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。设计目的是为了拉一条独立的线程出来，以便处理一些比较大的计算量等</p>
<h2 id="3-2-Service-Worker"><a href="#3-2-Service-Worker" class="headerlink" title="3.2 Service Worker"></a>3.2 Service Worker</h2><p>Service Worker 可以做和Web Worker一样的事情，但是Service Worker是为缓存而设计的。<br>参考：淘宝网的service worker，其使用了google官方的工具workbox定义其缓存策略：</p>
<h1 id="4-浏览器网络"><a href="#4-浏览器网络" class="headerlink" title="4 浏览器网络"></a>4 浏览器网络</h1><h2 id="4-1-http协议"><a href="#4-1-http协议" class="headerlink" title="4.1 http协议"></a>4.1 http协议</h2><p>http协议是基于TCP/IP的通讯协议，http请求与响应的结构如下：<br>http请求：</p>
<ul>
<li>schema://域名:端口/路径?查询#xx</li>
<li>方法</li>
<li>协议</li>
<li>消息体</li>
<li>头信息</li>
</ul>
<ul>
<li>缓存控制<ul>
<li>cookie</li>
<li>User Agent</li>
<li>来源</li>
<li>其他<br>http响应：</li>
</ul>
</li>
</ul>
<ul>
<li>状态码</li>
<li>消息体</li>
<li>头信息</li>
<li>缓存控制</li>
<li>set-cookie</li>
<li>其他</li>
</ul>
<p>Http2.0相较于Http1.1的区别：<br>HTTP1.1：</p>
<ul>
<li>一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接</li>
</ul>
<p>HTTP2.0： </p>
<pre><code>- 一次请求多次响应：多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行，由此优化了性能
</code></pre><ul>
<li>服务端推送：把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。</li>
<li>合并多次请求的头信息</li>
</ul>
<h2 id="4-2-浏览器网络安全相关"><a href="#4-2-浏览器网络安全相关" class="headerlink" title="4.2 浏览器网络安全相关"></a>4.2 浏览器网络安全相关</h2><ol>
<li><p>运营商劫持<br>分为 1）DNS劫持：通过攻击域名解析服务器（DNS），或伪造域名解析服务器（DNS）的方法，把目标网站域名解析到错误的地址从而实现用户无法访问目标网站的目的。主要预防方法是使用固定的DNS地址<br>2）HTTP劫持：在运营商的路由器节点上，设置协议检测，一旦发现是HTTP请求，而且是html类型请求，则拦截处理。后续做法往往分为2种，1种是类似DNS劫持返回302让用户浏览器跳转到另外的地址，还有1种是在服务器返回的HTML数据中插入js或dom节点（广告）。</p>
</li>
<li><p>MiM中间人攻击<br>MiM即Man in the Middle,中间人攻击。攻击者在请求和响应传输途中，拦截并篡改内容。</p>
</li>
</ol>
<h1 id="5-跨域问题"><a href="#5-跨域问题" class="headerlink" title="5 跨域问题"></a>5 跨域问题</h1><h2 id="5-1-同源策略"><a href="#5-1-同源策略" class="headerlink" title="5.1 同源策略"></a>5.1 同源策略</h2><p>同源，指的是协议，域名，端口相同。浏览器处于安全方面的考虑，只允许本域名下的接口交互，不同源的客户端脚本，在没有明确授权的情况下，不能读写对方的资源。</p>
<h2 id="5-2-跨域方案"><a href="#5-2-跨域方案" class="headerlink" title="5.2 跨域方案"></a>5.2 跨域方案</h2><ol>
<li><p>JSONP</p>
<p>利用script标签可以跨域的能力，web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件，客户端在对JSON文件调用成功之后，也就获得了自己所需的数据。为了便于客户端使用数据，逐渐形成了一种非正式传输协议，称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。<br>JSONP存在的问题：</p>
<ul>
<li>只支持GET</li>
<li>风险代码注入</li>
</ul>
</li>
<li>CORS</li>
</ol>
<p>使用额外的请求头Access-Allow-Origin-Control来告诉浏览器让运行在一个origin上的Web应用被准许访问来自不同源服务器上的指定的资源。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/15/浏览器知识总结/" data-id="ck6nisdb4000cf0uosr5j2zss" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Canvas绘制图形" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/27/Canvas绘制图形/" class="article-date">
  <time datetime="2019-09-27T06:57:37.000Z" itemprop="datePublished">2019-09-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/27/Canvas绘制图形/">Canvas绘制图形</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近几天研究了一下使用 Canvas 在图片上划分出一块区域的功能，具体需求是在图片上圈出一块区域并重新生成图片。实现如下；</p>
<p>html 部分，因为要实现橡皮的功能，所以这里使用了两层 canvas，底层 canvas 绘制原图片，上层 canvas 用于画笔绘制和擦除：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"container"</span> style=<span class="string">"position: relative"</span>&gt;</span><br><span class="line">  &lt;canvas id=<span class="string">"oriCanvas"</span> width=<span class="string">"1000"</span> height=<span class="string">"1000"</span> style=<span class="string">"position: relative; left:0; top:0;"</span>&gt;&lt;/canvas&gt;</span><br><span class="line">  &lt;canvas id=<span class="string">"maskCanvas"</span> width=<span class="string">"1000"</span> height=<span class="string">"1000"</span> style=<span class="string">"position: absolute;left:0;top:0;z-index:99;"</span>&gt;&lt;/canvas&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"toolbar"</span>&gt;</span><br><span class="line">    &lt;button id=<span class="string">"eraser"</span>&gt;擦除&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button id="pen"&gt;绘制&lt;/</span>button&gt;</span><br><span class="line">    &lt;button id=<span class="string">"gen"</span>&gt;生成&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>首先， 进行原图像的绘制, 为了避免在图片未加载完成时绘制图片无效，在 Image 的 onload 事件中进行图片的绘制：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oriCanvas = <span class="built_in">document</span>.getElementById(<span class="string">'oriCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> maskCanvas = <span class="built_in">document</span>.getElementById(<span class="string">'maskCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> oriCtx = oriCanvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> maskCtx = maskCanvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  img = <span class="keyword">new</span> Image();</span><br><span class="line">  img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    isImgLoaded = <span class="literal">true</span>;</span><br><span class="line">    oriCanvas.width = <span class="keyword">this</span>.width;</span><br><span class="line">    oriCanvas.height = <span class="keyword">this</span>.height;</span><br><span class="line">    maskCanvas.width = <span class="keyword">this</span>.width;</span><br><span class="line">    maskCanvas.height = <span class="keyword">this</span>.height;</span><br><span class="line">    drawImage();</span><br><span class="line">  &#125;;</span><br><span class="line">  img.src = <span class="string">"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1569233132184&amp;di=a1a45444230d083a872aff5db08ec216&amp;imgtype=0&amp;src=http%3A%2F%2Fphotocdn.sohu.com%2F20090224%2FImg262436027.jpg"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawImage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  oriCtx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在按下鼠标时，记下当前鼠标所在位置，并标记当前是正在绘制中/擦除中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">maskCanvas.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isPenSelected) &#123;</span><br><span class="line">    isPainting = <span class="literal">true</span>;</span><br><span class="line">    startX = e.pageX - maskCanvas.offsetLeft;</span><br><span class="line">    startY = e.pageY - maskCanvas.offsetTop;</span><br><span class="line">    prevX = startX;</span><br><span class="line">    prevY = startY;</span><br><span class="line">    maskCtx.beginPath();</span><br><span class="line">    maskCtx.moveTo(startX, startY);</span><br><span class="line">    maskCtx.lineWidth = <span class="number">1</span>;</span><br><span class="line">    maskCtx.strokeStyle = <span class="string">'#fff'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    isClearing = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>鼠标移动时，计算出当前坐标，并根据当前的操作进行绘制/擦除。绘制时将当前鼠标所在点与上一个点直接进行连接，擦除使用 clearRect 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">maskCanvas.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  curX = e.pageX - maskCanvas.offsetLeft;</span><br><span class="line">  curY = e.pageY - maskCanvas.offsetTop;</span><br><span class="line">  <span class="keyword">if</span> (isPainting) &#123;</span><br><span class="line">    drawPath(curX, curY);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isClearing) &#123;</span><br><span class="line">    clear(curX, curY);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawPath</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  maskCtx.lineTo(x, y);</span><br><span class="line">  maskCtx.stroke();</span><br><span class="line">  prevX = x;</span><br><span class="line">  prevY = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clear</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  maskCtx.clearRect(x, y, <span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，点击”生成”按钮，将两层canvas合并并导出图片：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gen.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  oriCtx.drawImage(maskCanvas, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">var</span> resImg = oriCanvas.toDataURL();</span><br><span class="line">  <span class="keyword">var</span> resEl = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">  resEl.src = resImg;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>).append(resEl);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/27/Canvas绘制图形/" data-id="ck6nisdal0001f0uoe39nilv9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Vue源码学习之三" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/06/Vue源码学习之三/" class="article-date">
  <time datetime="2019-09-06T08:50:35.000Z" itemprop="datePublished">2019-09-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/06/Vue源码学习之三/">Vue源码学习之三</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Vue实例的初始化中stateMixin以及数据双向绑定部分在本次博客中学习。</p>
<p>来到 <code>src/core/instance/state.js</code> 文件中，这里主要对 Vue 实例选项的 data\watch\computed\props\methods 属性做了初始化：</p>
<ol>
<li>props</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initProps</span> (<span class="params">vm: Component, propsOptions: Object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在使用new 创建实例时，使用propsData属性</span></span><br><span class="line">  <span class="keyword">const</span> propsData = vm.$options.propsData || &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> props = vm._props = &#123;&#125;</span><br><span class="line">  <span class="comment">// cache prop keys so that future props updates can iterate using Array</span></span><br><span class="line">  <span class="comment">// instead of dynamic object key enumeration.</span></span><br><span class="line">  <span class="keyword">const</span> keys = vm.$options._propKeys = []</span><br><span class="line">  <span class="keyword">const</span> isRoot = !vm.$parent</span><br><span class="line">  <span class="comment">// root instance props should be converted</span></span><br><span class="line">  <span class="comment">// 如果没有父组件，则将shouldObserve置为false</span></span><br><span class="line">  <span class="keyword">if</span> (!isRoot) &#123;</span><br><span class="line">    toggleObserving(<span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> propsOptions) &#123;</span><br><span class="line">    keys.push(key)</span><br><span class="line">    <span class="comment">// validateProp设置默认值</span></span><br><span class="line">    <span class="comment">// 当default为undefined时，需要去observe</span></span><br><span class="line">    <span class="keyword">const</span> value = validateProp(key, propsOptions, propsData, vm)</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="comment">// hyphenate将驼峰转换为-格式</span></span><br><span class="line">      <span class="keyword">const</span> hyphenatedKey = hyphenate(key)</span><br><span class="line">      <span class="comment">// isReservedAttribute检查是否是保留字（key,ref,slot,slot-scope,is）</span></span><br><span class="line">      <span class="comment">// config.isReservedAttr: 检查是否是boolean</span></span><br><span class="line">      <span class="keyword">if</span> (isReservedAttribute(hyphenatedKey) ||</span><br><span class="line">          config.isReservedAttr(hyphenatedKey)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`"<span class="subst">$&#123;hyphenatedKey&#125;</span>" is a reserved attribute and cannot be used as component prop.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      defineReactive(props, key, value, () =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">`Avoid mutating a prop directly since the value will be `</span> +</span><br><span class="line">            <span class="string">`overwritten whenever the parent component re-renders. `</span> +</span><br><span class="line">            <span class="string">`Instead, use a data or computed property based on the prop's `</span> +</span><br><span class="line">            <span class="string">`value. Prop being mutated: "<span class="subst">$&#123;key&#125;</span>"`</span>,</span><br><span class="line">            vm</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      defineReactive(props, key, value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// static props are already proxied on the component's prototype</span></span><br><span class="line">    <span class="comment">// during Vue.extend(). We only need to proxy props defined at</span></span><br><span class="line">    <span class="comment">// instantiation here.</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      proxy(vm, <span class="string">`_props`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  toggleObserving(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面源码中就涉及到了Vue中的observer模式， 在Observer对象中绑定了getter/setter方法去收集依赖、监听变化并进行数据更新。</p>
<p>来到<code>src/core/observer/index/js</code>中看下Observer是如何定义的， 首先是Observer定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Observer class that is attached to each observed</span></span><br><span class="line"><span class="comment"> * object. Once attached, the observer converts the target</span></span><br><span class="line"><span class="comment"> * object's property keys into getter/setters that</span></span><br><span class="line"><span class="comment"> * collect dependencies and dispatch updates.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  value: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  vmCount: number; <span class="comment">// number of vms that have this object as root $data</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (value: any) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="keyword">this</span>.vmCount = <span class="number">0</span></span><br><span class="line">    <span class="comment">// def即封装的defineProperty,可写可配置</span></span><br><span class="line">    def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="comment">// hasProto: 能否使用__proto__</span></span><br><span class="line">      <span class="comment">// protoAgrument: 为对象的__proto__赋值</span></span><br><span class="line">      <span class="comment">// arrayMethods： 数组的方法</span></span><br><span class="line">      <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">        protoAugment(value, arrayMethods)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将数组方法按键值对形式赋给value，即value[arrayKey] = arrayMethod</span></span><br><span class="line">        copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对于value中每个元素，都去执行observe(value[i])</span></span><br><span class="line">      <span class="keyword">this</span>.observeArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果value不是数组的话，对value中每个属性执行defineReactive()</span></span><br><span class="line">      <span class="keyword">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>observe</code>方法定义如下，它主要做的事就是去构造Observer实例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempt to create an observer instance for a value,</span></span><br><span class="line"><span class="comment"> * returns the new observer if successfully observed,</span></span><br><span class="line"><span class="comment"> * or the existing observer if the value already has one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// 如果存在 __ob__这个属性，说明构造函数的参数已经是一个Observer对象了，直接返回value.__ob__</span></span><br><span class="line"> <span class="comment">// 否则构造一个新的Observer对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">value: any, asRootData: ?boolean</span>): <span class="title">Observer</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ob: Observer | <span class="keyword">void</span></span><br><span class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">'__ob__'</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">    ob = value.__ob__</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    shouldObserve &amp;&amp;</span><br><span class="line">    !isServerRendering() &amp;&amp;</span><br><span class="line">    (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class="line">    !value._isVue</span><br><span class="line">  ) &#123;</span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123;</span><br><span class="line">    ob.vmCount++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Observer</code>中的属性 <code>dep</code> 是一个 <code>Dep</code> 实例，<code>Dep</code> 是一个observable, 可以有多个指令去订阅它，其定义如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> target: ?Watcher;</span><br><span class="line">  id: number;</span><br><span class="line">  subs: <span class="built_in">Array</span>&lt;Watcher&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = uid++</span><br><span class="line">    <span class="keyword">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addSub (sub: Watcher) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeSub (sub: Watcher) &#123;</span><br><span class="line">    remove(<span class="keyword">this</span>.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      Dep.target.addDep(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">      <span class="comment">// subs aren't sorted in scheduler if not running async</span></span><br><span class="line">      <span class="comment">// we need to sort them now to make sure they fire in correct</span></span><br><span class="line">      <span class="comment">// order</span></span><br><span class="line">      subs.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看看 <code>defineReactive</code>，它主要用来给对象定义响应式的属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define a reactive property on an Object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  customSetter?: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  shallow?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set</span><br><span class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter () &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">      <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Reactive 就是一种可观测的数据模型，defineReactive中主要用 get和set去拦截数据的读取与变化。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/06/Vue源码学习之三/" data-id="ck6nisdar0004f0uojbn1db4b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Vue源码中知识点总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/06/Vue源码中知识点总结/" class="article-date">
  <time datetime="2019-09-06T03:10:35.000Z" itemprop="datePublished">2019-09-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/06/Vue源码中知识点总结/">Vue源码中知识点总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>native code</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isNative</span> (<span class="params">Ctor: any</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> Ctor === <span class="string">'function'</span> &amp;&amp; <span class="regexp">/native code/</span>.test(Ctor.toString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>Plain Object</li>
</ol>
<p>简单对象：通过{} 或 new() 创建的对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否位简单对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isPlainObject</span> (<span class="params">obj: any</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _toString.call(obj) === <span class="string">'[object Object]'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li><p>Object.isfrozon<br>判断一个对象是否被冻结。一个对象是冻结的是指它不可扩展，所有属性都是不可配置的，且所有数据属性（即没有getter或setter组件的访问器的属性）都是不可写的。</p>
</li>
<li><p>makeMap</p>
</li>
</ol>
<p>这个方法用于生成一个map并返回一个函数用于判断一个值是否在这个map中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">makeMap</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  str: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  expectsLowerCase?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): (<span class="params">key: string</span>) =&gt; <span class="title">true</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> list: <span class="built_in">Array</span>&lt;string&gt; = str.split(<span class="string">','</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">    map[list[i]] = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> expectsLowerCase</span><br><span class="line">    ? <span class="function"><span class="params">val</span> =&gt;</span> map[val.toLowerCase()]</span><br><span class="line">    : <span class="function"><span class="params">val</span> =&gt;</span> map[val]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>检测浏览器是否支持passive特性</li>
</ol>
<p>关于 passive:<br>  <a href="https://www.cnblogs.com/ziyunfei/p/5545439.html" target="_blank" rel="noopener">https://www.cnblogs.com/ziyunfei/p/5545439.html</a><br>  <a href="https://blog.csdn.net/dj0379/article/details/52883315" target="_blank" rel="noopener">https://blog.csdn.net/dj0379/article/details/52883315</a></p>
<p>检测方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> supportsPassive = <span class="literal">false</span>  <span class="comment">// 全局属性</span></span><br><span class="line"><span class="keyword">if</span> (inBrowser) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> opts = &#123;&#125;</span><br><span class="line">    <span class="comment">// defineProperty()方法在属性名不存在时会给对象创建属性名，执行下面这段代码后opts=&#123;passive: undefined&#125;</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(opts, <span class="string">'passive'</span>, (&#123;</span><br><span class="line">      <span class="keyword">get</span> () &#123;</span><br><span class="line">        <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">        supportsPassive = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;: <span class="built_in">Object</span>)) <span class="comment">// https://github.com/facebook/flow/issues/285</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'test-passive'</span>, <span class="literal">null</span>, opts)  <span class="comment">// 通过注册一个事件来执行opts中的getter</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>获取原生类型</li>
</ol>
<p>在任何值上调用 Object 原生的 toString() 方法，都会返回一个 [object NativeConstructorName] 格式的字符串。每个类在内部都有一个 [[Class]] 属性，这个属性中就指定了上述字符串中的构造函数名， 如 ‘[object Array]’</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toRawType</span> (<span class="params">value: any</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _toString.call(value).slice(<span class="number">8</span>, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>cached方法</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cached</span>&lt;<span class="title">F</span>: <span class="title">Function</span>&gt; (<span class="params">fn: F</span>): <span class="title">F</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span> <span class="title">cachedFn</span> (<span class="params">str: string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> hit = cache[str]</span><br><span class="line">    <span class="keyword">return</span> hit || (cache[str] = fn(str))</span><br><span class="line">  &#125;: any)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建了一个对象cache，返回执行函数，在执行函数中对字符串做相应的处理并存在cache中，下次再处理相同的字符串时，首先在cache中查找字符串对应的key，如果能找到则直接读取而无需重新处理，提高了执行速度。这里利用了闭包的特性，即返回的立即执行函数 cachedFn 可以引用起外部函数中的cache对象，即使当 cached 执行完毕后，其活动对象也不会销毁，cachedFn 仍然可以引用 cache，取得其最后一个值即已保存了混村对象的值。</p>
<p>用例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> camelizeRE = <span class="regexp">/-(\w)/g</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> camelize = cached((str: string): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(camelizeRE, (_, c) =&gt; c ? c.toUpperCase() : <span class="string">''</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>bind polyfill</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">polyfillBind</span> (<span class="params">fn: Function, ctx: Object</span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">boundFn</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> l = <span class="built_in">arguments</span>.length</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">      ? l &gt; <span class="number">1</span></span><br><span class="line">        ? fn.apply(ctx, <span class="built_in">arguments</span>)</span><br><span class="line">        : fn.call(ctx, a)</span><br><span class="line">      : fn.call(ctx)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  boundFn._length = fn.length</span><br><span class="line">  <span class="keyword">return</span> boundFn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nativeBind</span> (<span class="params">fn: Function, ctx: Object</span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fn.bind(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> bind = <span class="built_in">Function</span>.prototype.bind</span><br><span class="line">  ? nativeBind</span><br><span class="line">  : polyfillBind</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/06/Vue源码中知识点总结/" data-id="ck6nisdap0003f0uozk2aif74" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Vue源码学习之二" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/23/Vue源码学习之二/" class="article-date">
  <time datetime="2019-08-23T05:44:03.000Z" itemprop="datePublished">2019-08-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/23/Vue源码学习之二/">Vue源码学习之二</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本周继续Vue源码的学习。上周主要看了Vue的构造函数，这周主要研究Vue源码构造函数中的初始化方法，即上篇博客中提到的 initMixin, stateMixin, eventsMixin, lifecycleMixin和 renderMixin</p>
<h2 id="initMixin"><a href="#initMixin" class="headerlink" title="initMixin"></a>initMixin</h2><p>在这里主要是抛出了Vue的初始化方法 <code>_init</code>。 在<code>_init</code>中主要做的有以下几件事：</p>
<ul>
<li><p>设置 <code>_uid</code>， 将实例缓存到 <code>vm</code> 中</p>
</li>
<li><p>环境变量不是 <code>production</code> 时，测试性能</p>
</li>
<li><p>如果 <code>Vue</code> 的初始化选项 <code>options</code> (data、生命周期钩子、methods、mixins等）中有 <code>_isComponent</code>这个选项(用于表明当前实例是否是组件的一个flag)，去优化组件实例</p>
</li>
<li><p>否则执行 <code>mergeOptions</code> 这个函数，这个函数的作用是将传入的选项和自身的选项merge</p>
</li>
<li><p>在对选项处理完后，去对生命周期、事件等做初始化，并调用 <code>beforeCreate</code> 和 <code>created</code> 钩子函数<br>来看看具体代码：</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: Object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// a uid</span></span><br><span class="line">    vm._uid = uid++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> startTag, endTag</span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="comment">// 性能优化</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">      startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">      endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">      mark(startTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a flag to avoid this being observed</span></span><br><span class="line">    vm._isVue = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// merge options</span></span><br><span class="line">    <span class="comment">// _isComponent 用于标识 Vue 实例是否是组件</span></span><br><span class="line">    <span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">      <span class="comment">// optimize internal component instantiation</span></span><br><span class="line">      <span class="comment">// since dynamic options merging is pretty slow, and none of the</span></span><br><span class="line">      <span class="comment">// internal component options needs special treatment.</span></span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      initInternalComponent(vm, options)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vm.$options = mergeOptions(</span><br><span class="line">        resolveConstructorOptions(vm.constructor),</span><br><span class="line">        options || &#123;&#125;,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="comment">// 如果不是在生产环境，初始化proxy</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      initProxy(vm)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vm._renderProxy = vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// expose real self</span></span><br><span class="line">    vm._self = vm</span><br><span class="line">    initLifecycle(vm) <span class="comment">// 生命周期相关的初始化</span></span><br><span class="line">    initEvents(vm) <span class="comment">// 事件相关初始化</span></span><br><span class="line">    initRender(vm) <span class="comment">// 渲染相关初始化</span></span><br><span class="line">    callHook(vm, <span class="string">'beforeCreate'</span>) <span class="comment">// 调用beforeCreate</span></span><br><span class="line">    initInjections(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line">    initState(vm) <span class="comment">// 初始化data，进行双向绑定</span></span><br><span class="line">    initProvide(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line">    callHook(vm, <span class="string">'created'</span>) <span class="comment">// 调用created</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">      vm._name = formatComponentName(vm, <span class="literal">false</span>)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">$&#123;vm._name&#125;</span> init`</span>, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">      vm.$mount(vm.$options.el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>了解了大概的初始化流程之后，来具体看一下相关函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveConstructorOptions</span> (<span class="params">Ctor: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> options = Ctor.options</span><br><span class="line">  <span class="keyword">if</span> (Ctor.super) &#123;</span><br><span class="line">    <span class="keyword">const</span> superOptions = resolveConstructorOptions(Ctor.super)</span><br><span class="line">    <span class="keyword">const</span> cachedSuperOptions = Ctor.superOptions</span><br><span class="line">    <span class="keyword">if</span> (superOptions !== cachedSuperOptions) &#123;</span><br><span class="line">      <span class="comment">// super option changed,</span></span><br><span class="line">      <span class="comment">// need to resolve new options.</span></span><br><span class="line">      Ctor.superOptions = superOptions</span><br><span class="line">      <span class="comment">// check if there are any late-modified/attached options (#4976)</span></span><br><span class="line">      <span class="comment">// resolveModifiedOptions 返回</span></span><br><span class="line">      <span class="keyword">const</span> modifiedOptions = resolveModifiedOptions(Ctor)</span><br><span class="line">      <span class="comment">// update base extend options</span></span><br><span class="line">      <span class="keyword">if</span> (modifiedOptions) &#123;</span><br><span class="line">        extend(Ctor.extendOptions, modifiedOptions)</span><br><span class="line">      &#125;</span><br><span class="line">      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions)</span><br><span class="line">      <span class="keyword">if</span> (options.name) &#123;</span><br><span class="line">        options.components[options.name] = Ctor</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> options</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>resolveConstructorOptions</code>这个函数用于解析构造函数中的选项 <code>options</code>。<code>Ctor.super</code> 是当 Ctor 是 <code>Vue.extend</code> 构建的子类时，它就会具有 <code>super</code> 这个属性。此时，去对比 Ctor 与其父类的 options ，如果不一样的话，说明父类的 options 已被修改过（比如有mixins），那么就调用 <code>extend</code> 函数将已修改过的部分扩展到 <code>Ctor</code> 的 <code>options</code> 中。</p>
<p>扩展函数 <code>extend</code> 如下，这里是用到这个函数将父类中修改后的选项逐一添加到 Ctor 的选项中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">extend</span> (<span class="params">to: Object, _from: ?Object</span>): <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> _from) &#123;</span><br><span class="line">    to[key] = _from[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> to</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 <code>mergeOptions</code> 则是对 options 中各项属性 data、 watch等与父类进行合并。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/23/Vue源码学习之二/" data-id="ck6nisdas0005f0uo2mahyz8z" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Vue源码学习之一" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/17/Vue源码学习之一/" class="article-date">
  <time datetime="2019-08-17T05:45:18.000Z" itemprop="datePublished">2019-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/17/Vue源码学习之一/">Vue源码学习之一</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这个星期开始看Vue 2.6.10版本的源码。首先从入口文件开始，在 <code>package.json</code> 中看到：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"rollup -w -c scripts/config.js --environment TARGET:web-full-dev"</span>,</span><br><span class="line">    <span class="string">"dev:cjs"</span>: <span class="string">"rollup -w -c scripts/config.js --environment TARGET:web-runtime-cjs-dev"</span>,</span><br><span class="line">    <span class="string">"dev:esm"</span>: <span class="string">"rollup -w -c scripts/config.js --environment TARGET:web-runtime-esm"</span>,</span><br><span class="line">    <span class="string">"dev:test"</span>: <span class="string">"karma start test/unit/karma.dev.config.js"</span>,</span><br><span class="line">    <span class="string">"dev:ssr"</span>: <span class="string">"rollup -w -c scripts/config.js --environment TARGET:web-server-renderer"</span>,</span><br><span class="line">    <span class="string">"dev:compiler"</span>: <span class="string">"rollup -w -c scripts/config.js --environment TARGET:web-compiler "</span>,</span><br><span class="line">    <span class="string">"dev:weex"</span>: <span class="string">"rollup -w -c scripts/config.js --environment TARGET:weex-framework"</span>,</span><br><span class="line">    <span class="string">"dev:weex:factory"</span>: <span class="string">"rollup -w -c scripts/config.js --environment TARGET:weex-factory"</span>,</span><br><span class="line">    <span class="string">"dev:weex:compiler"</span>: <span class="string">"rollup -w -c scripts/config.js --environment TARGET:weex-compiler "</span>,</span><br></pre></td></tr></table></figure>
<p>第一行也就是运行 <code>npm run dev</code>时做的事情，这里是根据<code>scripts/config.js</code> 配置文件去打包项目，环境变量是<code>TARGET=web-full-dev</code>。 找到<code>scripts/config.js</code>文件，找到 <code>web-full-dev</code>对应的配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Runtime+compiler development build (Browser)</span></span><br><span class="line"><span class="string">'web-full-dev'</span>: &#123;</span><br><span class="line">  entry: resolve(<span class="string">'web/entry-runtime-with-compiler.js'</span>),</span><br><span class="line">  dest: resolve(<span class="string">'dist/vue.js'</span>),</span><br><span class="line">  format: <span class="string">'umd'</span>,</span><br><span class="line">  env: <span class="string">'development'</span>,</span><br><span class="line">  alias: &#123; <span class="attr">he</span>: <span class="string">'./entity-decoder'</span> &#125;,</span><br><span class="line">  banner</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>  入口文件为 <code>&#39;src/platforms/web/entry-runtime-with-compiler.js</code>, 找到该文件，找到以下代码：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'./runtime/index'</span></span><br></pre></td></tr></table></figure>
<p>  依次找下去，依据路径<code>src/platforms/web/runtime/index</code> -&gt; <code>src/core/index</code> -&gt; <code>src/core/instance/index.js</code> 找到Vue的构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>._init(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个文件中还对 <code>Vue</code> 做了初始化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initMixin(Vue)</span><br><span class="line">stateMixin(Vue)</span><br><span class="line">eventsMixin(Vue)</span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line">renderMixin(Vue)</span><br></pre></td></tr></table></figure>
<p><code>_init</code> 是 <code>initMixin</code> 中挂载在 <code>Vue</code> 原型上的方法。</p>
<p>而 <code>stateMixin</code>, <code>eventsMixin</code>,<code>lifecycleMixin</code>,<code>renderMixin</code>则分别在 <code>Vue.prototype</code> 挂载了以下方法/属性：</p>
<ul>
<li><p>stateMixin: 挂载$data, $props, $set, $delete, $watch，和数据处理相关</p>
</li>
<li><p>eventsMixin: 和事件处理相关的， $on, $off, $emit, $once</p>
</li>
<li><p>lifecycleMixin: 处理生命周期， 在 Vue.prototype 上挂载 _update, $forceUpdate, $destroy</p>
</li>
<li><p>renderMixin: $nextTick, _render</p>
</li>
</ul>
<p>再回到 <code>src/core/index</code> 看看这个文件中引入 <code>Vue</code> 实例之后做了什么：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要挂载一些静态属性和方法</span></span><br><span class="line">initGlobalAPI(Vue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂载$isServer： 是否运行于服务器</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$isServer'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: isServerRendering</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Object.defineProperty(Vue.prototype, '$ssrContext', &#123;</span><br><span class="line">  <span class="keyword">get</span> () &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$vnode &amp;&amp; <span class="keyword">this</span>.$vnode.ssrContext</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// expose FunctionalRenderContext for ssr runtime helper installation</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Vue, <span class="string">'FunctionalRenderContext'</span>, &#123;</span><br><span class="line">  value: FunctionalRenderContext</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Vue.version = <span class="string">'__VERSION__'</span></span><br></pre></td></tr></table></figure>
<p>再回到<code>src/platforms/web/runtime/index</code>中，这里主要给 Vue 做了一些全局配置以及配置了一些初始化选项。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/17/Vue源码学习之一/" data-id="ck6nisdae0000f0uozminp4q2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-element源码学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/09/element源码学习/" class="article-date">
  <time datetime="2019-08-09T07:33:13.000Z" itemprop="datePublished">2019-08-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/09/element源码学习/">element源码学习之clickoutside</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>clickoutside是element-ui中的一个指令, 用于在点击绑定元素外部时，执行指定的操作。主要原理是监听 <code>mouseup</code> 和 <code>mousedown</code> 事件，在 <code>mouseup</code>时，如果判断到事件所在元素不属于指令所绑定的元素，则执行指令绑定的回调方法。</p>
<p>来看看源码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// on 是element中封装的一个方法，兼容不同浏览器及服务器端的事件监听</span></span><br><span class="line"><span class="keyword">import</span> &#123; on &#125; <span class="keyword">from</span> <span class="string">'element-ui/src/utils/dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nodeList 存放所有绑定了clickoutside指令的元素</span></span><br><span class="line"><span class="keyword">const</span> nodeList = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ctx = <span class="string">'@@clickoutsideContext'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> startClick;</span><br><span class="line"><span class="keyword">let</span> seed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标按下时，startClick 存储 mousedown 事件</span></span><br><span class="line">!Vue.prototype.$isServer &amp;&amp; on(<span class="built_in">document</span>, <span class="string">'mousedown'</span>, e =&gt; (startClick = e));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标松开，对于所有绑定了clickoutside事件的节点，执行节点绑定的回调函数</span></span><br><span class="line">!Vue.prototype.$isServer &amp;&amp; on(<span class="built_in">document</span>, <span class="string">'mouseup'</span>, e =&gt; &#123;</span><br><span class="line">  nodeList.forEach(<span class="function"><span class="params">node</span> =&gt;</span> node[ctx].documentHandler(e, startClick));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面这段代码中， <code>Vue.prototype.$isSever</code> 用于判断Vue实例是否运行于服务器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createDocumentHandler</span>(<span class="params">el, binding, vnode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">mouseup = &#123;&#125;, mousedown = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!vnode ||</span><br><span class="line">      !vnode.context ||</span><br><span class="line">      !mouseup.target ||</span><br><span class="line">      !mousedown.target ||</span><br><span class="line">      el.contains(mouseup.target) ||</span><br><span class="line">      el.contains(mousedown.target) ||</span><br><span class="line">      el === mouseup.target ||</span><br><span class="line">      (vnode.context.popperElm &amp;&amp;</span><br><span class="line">      (vnode.context.popperElm.contains(mouseup.target) ||</span><br><span class="line">      vnode.context.popperElm.contains(mousedown.target)))) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (binding.expression &amp;&amp;</span><br><span class="line">      el[ctx].methodName &amp;&amp;</span><br><span class="line">      vnode.context[el[ctx].methodName]) &#123;</span><br><span class="line">      vnode.context[el[ctx].methodName]();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      el[ctx].bindingFn &amp;&amp; el[ctx].bindingFn();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>createDocumentHandler</code> 判断需要执行回调的情形，并为指令绑定的节点添加回调方法。判断的情形如下：</p>
<ul>
<li><p><code>!vnode.context</code>：不存在则退出</p>
</li>
<li><p><code>!mouseup.target</code>: 未触发点击事件，退出</p>
</li>
<li><p><code>!mousedown.target</code>： 未触发点击事件，退出</p>
</li>
<li><p><code>el.contains(mouseup.target)</code>, <code>el.contains(mousedown.target)</code>: 绑定的元素包含点击的元素，则退出不执行绑定回调方法</p>
</li>
<li><p><code>el === mouseup.target</code>: 点击绑定的元素，则不执行绑定的回调方法</p>
</li>
<li><p><code>(vnode.context.popperElm &amp;&amp;(vnode.context.popperElm.contains(mouseup.target) ||
vnode.context.popperElm.contains(mousedown.target))))</code>: 如果点击在下拉菜单上，则退出不执行绑定回调方法</p>
</li>
</ul>
<p>如果点击的事件不是上述情况的话，那么给绑定元素的 <code>ctx</code> 属性添加绑定的回调函数，并执行回调函数。</p>
<p>最后 export 出去的是指令的配置，主要是其钩子函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指令绑定时调用</span></span><br><span class="line">bind(el, binding, vnode) &#123;</span><br><span class="line">    <span class="comment">// 将绑定该指令的元素添加到nodeList中</span></span><br><span class="line">    nodeList.push(el);</span><br><span class="line">    <span class="comment">// seed作为标识符</span></span><br><span class="line">    <span class="keyword">const</span> id = seed++;</span><br><span class="line">    el[ctx] = &#123;</span><br><span class="line">      id,</span><br><span class="line">      documentHandler: createDocumentHandler(el, binding, vnode),</span><br><span class="line">      methodName: binding.expression,</span><br><span class="line">      bindingFn: binding.value</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// vNode更新时调用</span></span><br><span class="line">  update(el, binding, vnode) &#123;</span><br><span class="line">    el[ctx].documentHandler = createDocumentHandler(el, binding, vnode);</span><br><span class="line">    el[ctx].methodName = binding.expression;</span><br><span class="line">    el[ctx].bindingFn = binding.value;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指令与元素解绑时调用</span></span><br><span class="line">  <span class="comment">// 解绑时，将元素从nodeList中删除</span></span><br><span class="line">  unbind(el) &#123;</span><br><span class="line">    <span class="keyword">let</span> len = nodeList.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nodeList[i][ctx].id === el[ctx].id) &#123;</span><br><span class="line">        nodeList.splice(i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> el[ctx];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在元素绑定指令时，即给元素的ctx属性赋了一个对象，这个对象具有以下属性：</p>
<ul>
<li><p><code>id</code>：给绑定元素的一个唯一的标识符</p>
</li>
<li><p><code>documentHandler</code>: 即前面createDocumentHandler所返回的函数，如前，在 <code>mouseup</code>触发时便会去遍历绑定元素去执行 <code>documentHandler</code></p>
</li>
<li><p><code>methodName</code>: 指令绑定的expression</p>
</li>
<li><p><code>bindingFn</code>: 指令绑定的value</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/09/element源码学习/" data-id="ck6nisdav0007f0uoafyt18f2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-web安全之xss攻击" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/05/web安全之xss攻击/" class="article-date">
  <time datetime="2019-08-05T01:53:54.000Z" itemprop="datePublished">2019-08-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/05/web安全之xss攻击/">web安全之xss攻击</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上篇blog学习了web安全领域中的 CSRF 攻击，这篇来说一下 XSS。</p>
<p>XSS（Cross Site Script）又名跨站脚本攻击，是攻击者在网页上注入恶意的客户端脚本，通过恶意的脚本篡改客户端网页，从而导致用户隐私泄露或用户浏览器被控制。</p>
<h2 id="XSS-攻击的方式"><a href="#XSS-攻击的方式" class="headerlink" title="XSS 攻击的方式"></a>XSS 攻击的方式</h2><p>XSS可能的攻击方式有：</p>
<ol>
<li>将包含攻击脚本的恶意url包装在图片、游戏外挂或其他具有诱惑力的内容中，当用户点击这个恶意url，其中的脚本被执行即产生了XSS攻击。</li>
</ol>
<p>例如，现在网页上有个链接，其指向地址为 <code>xxx.com?a=b</code>, 用户访问这个链接即向XSS攻击后台服务器发起一个请求，服务器收到请求后返回一段攻击代码，客户端收到返回的恶意代码后在网页执行即完成了一次攻击。</p>
<ol start="2">
<li>将对客户端的攻击脚本植入到服务器上，那么每个正常访问该页面的用户都会受到攻击。</li>
</ol>
<p>例如，当用户提交内容时，服务端监听用户提交，在用户提交时将用户填入的信息保存在服务端，在用户正常访问这个页面时，服务端返回之前用户提交的信息。那么如果用户提交的是一段恶意代码，这段恶意代码就会被保存在服务器端并在所有用户访问这个页面时被执行。</p>
<p>XSS 攻击还有其他方式，如改变页面中某个结构在其中嵌入代码。总结起来就是通过各种方式将可执行脚本植入页面中。</p>
<h2 id="XSS的防御"><a href="#XSS的防御" class="headerlink" title="XSS的防御"></a>XSS的防御</h2><ol>
<li>任何用户的输入都是不可信的，对用户的输入需要做过滤、转义。例如 <code>&lt;script&gt;</code>需要对 <code>&lt;</code> 和 <code>&gt;</code> 做转义。</li>
</ol>
<p>当然，用户输入也不止输入框一种形式，还有诸如 <code>xxx.com?a=b&amp;c=d</code>这种通过 url 中查询参数等形式以及post参数等，需要全面考虑各种用户输入的情形。</p>
<ol start="2">
<li><p>除了<code>&lt;script&gt;</code>之外，攻击者也有可能通过 html 片段在页面中渲染不安全的内容。例如使用 <code>span</code>、<code>p</code>标签等渲染不安全的内容，在 <code>input</code>输入中放置不安全的 <code>value</code>等，在 <code>a</code>标签中植入不安全的链接等。 那么就需要做html编码、url校验与安全性认证等工作去防御 xss 攻击。</p>
</li>
<li><p>对服务端的输出，除了富文本输出外，也需要做过滤与转义之后再输出到页面中。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/05/web安全之xss攻击/" data-id="ck6nisday0009f0uoztgzt3pb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-web安全之CSRF攻击" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/17/web安全之CSRF攻击/" class="article-date">
  <time datetime="2019-07-17T02:12:12.000Z" itemprop="datePublished">2019-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/17/web安全之CSRF攻击/">web安全之CSRF攻击</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是-CSRF"><a href="#什么是-CSRF" class="headerlink" title="什么是 CSRF"></a>什么是 <code>CSRF</code></h2><p>跨站请求伪造(Cross-Site Request Forery), 通常缩写为 <code>CSRF</code> 或 <code>XSRF</code>, 是指一种恶意的网站应用，通过伪装成受信任用户的请求来利用受信任的网站完成攻击。</p>
<h2 id="CSRF-基本流程"><a href="#CSRF-基本流程" class="headerlink" title="CSRF 基本流程"></a><code>CSRF</code> 基本流程</h2><ul>
<li>用户登录 A 网站 <code>a.com</code></li>
<li>用户在保持 A 网站登陆状态的同时，受引访问了 B 网站 <code>b.com</code></li>
<li>B 网站向 A 网站发送请求，如 <code>a.com?action=xxx</code>, 其请求中往往带有一些有损 A 网站用户或者窃取信息等的操作</li>
<li>A 网站在收到 B 网站发来的请求后，此时由于A 网站用户的登录凭证还保留在 <code>cookie</code>中，A 网站默认使用受害用户的 cookie</li>
<li>A 网站以受害用户的名义执行了攻击者请求中的操作，CSRF 攻击完成</li>
</ul>
<p>下图描述了 <code>CSRF</code> 的基本流程(图源见水印)</p>
<p><img src="/images/0717/CSRF.png" alt="avatar"></p>
<h2 id="如何防范-CSRF-攻击"><a href="#如何防范-CSRF-攻击" class="headerlink" title="如何防范 CSRF 攻击"></a>如何防范 <code>CSRF</code> 攻击</h2><h3 id="设置-Referer-header"><a href="#设置-Referer-header" class="headerlink" title="设置 Referer header"></a>设置 Referer header</h3><p><code>CSRF</code> 攻击只能通过冒用他人 cookie 而不能读取 cookie。针对该特点，可以通过同源检测来防范 <code>CSRF</code> 攻击。</p>
<p>Http 请求头中有一个名为 <code>referer</code> 的字段，这个字段的作用提供访问来源，即告诉服务器当前请求是从哪个页面链接过来的。利用 <code>referer</code>, 服务器可以判断发起请求的来源，阻止不可信的外域请求。</p>
<p>但是这种方法也并不是完美的，它具有以下缺点：</p>
<ul>
<li><p><code>Referer</code> 在各浏览器的实现不尽相同，难以保证浏览器本身没有安全漏洞</p>
</li>
<li><p>用户可能自己设置浏览器使其在发送请求时不带 referer，这种情况下，当他们访问网站时，网站会因为其没有 <code>referer</code> 而认为是 <code>CSRF</code> 攻击，从而阻挡掉一部分正常用户的请求。</p>
</li>
</ul>
<h3 id="请求时附加额外信息进行验证"><a href="#请求时附加额外信息进行验证" class="headerlink" title="请求时附加额外信息进行验证"></a>请求时附加额外信息进行验证</h3><p>同样的利用<code>CSRF</code> 攻击只能通过冒用他人 cookie 而不能读取用户信息如 cookie 的特点，<code>CSRF</code> 攻击主要是因为服务器把攻击者的请求当成了是安全用户的请求。那么如果要求用户请求时带上一些额外的验证信息，如 <code>token</code>，那么服务器在接收到请求时，便可以通过判断 token 是否有效来验证请求是否安全。关于 <code>token</code> 认证具体原理与流程可参考上一篇博客。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/17/web安全之CSRF攻击/" data-id="ck6nisdb0000af0uouis2glmu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-基于Token的身份验证方案" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/16/基于Token的身份验证方案/" class="article-date">
  <time datetime="2019-07-16T07:41:12.000Z" itemprop="datePublished">2019-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/16/基于Token的身份验证方案/">基于Token的身份验证方案</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>客户端在向服务端请求资源的时候，由于有些资源是需要用户身份才能拿到的，这时候就要进行用户身份认证。而HTTP协议是无状态的，即当一个客户端请求发送给服务器的时候，服务器并不知道上一次发送请求的客户端的身份。每次发送请求都必须重新登录进行身份，要解决这个问题，常见的方案有基于会话的身份验证方案和基于Token的身份验证方案。</p>
<h2 id="传统身份验证的方法"><a href="#传统身份验证的方法" class="headerlink" title="传统身份验证的方法"></a>传统身份验证的方法</h2><p>传统的用户身份认证基于会话。用户请求登录时，服务端经过验证登录信息没有问题时，会生成一条会话记录，这条记录里面说明了登录的用户是谁。服务器端返回给客户端一个 sessionID，客户端将 sessionID 存储在 Cookie 中，在下次这个用户请求时，带上这个Cookie，服务器端收到这个Cookie后，取出其中的 sessionID 并在已存储的会话信息中查找，如果找到了该sessionID的话，说明用户已登录过尚在会话期间，那么就将用户请求的数据返回而无需重新登录。</p>
<p>基于会话的用户身份认证存在以下的问题：</p>
<ul>
<li>对每个用户的认证信息都需要存储在服务端，当用户会话增多之后，会增加服务器的存储开销</li>
<li>容易受到XSRF攻击</li>
</ul>
<h2 id="基于-Token-的身份认证方式"><a href="#基于-Token-的身份认证方式" class="headerlink" title="基于 Token 的身份认证方式"></a>基于 Token 的身份认证方式</h2><p>基于 Token 的身份认证方式主要工作流程如下：</p>
<ol>
<li><p>用户携带用户名和密码等信息请求访问</p>
</li>
<li><p>服务端校验用户信息没有问题后，生成一个 token</p>
</li>
<li><p>服务端将 token 返回给客户端</p>
</li>
<li><p>客户端将 token 存储在本地</p>
</li>
<li><p>在之后的每一次请求中客户端都携带 token， 服务端校验 token</p>
</li>
</ol>
<h3 id="Token-的实施-–-JWT"><a href="#Token-的实施-–-JWT" class="headerlink" title="Token 的实施 – JWT"></a>Token 的实施 – JWT</h3><p>JWT 的全程为 JSON Web Tokens，它是一个一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。</p>
<p>JWT 标准的 Token 有三个部分：</p>
<ul>
<li>header</li>
<li>payload</li>
<li>signature</li>
</ul>
<p>这三部分中间用 <code>.</code> 分隔开。</p>
<p>Header 是 JWT 的头部数据，里面包含了使用的算法与 token 的类型的 JSON 对象。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &apos;typ: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将此JSON对象使用 base64 算法转换为字符串即为 JWT header。</p>
<p>Payload 是 JWT 的主体内容部分， 也是一个 JSON 对象，其中包含了需要传递的数据，如发行人、到期时间、发布时间等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;iss&quot;：&quot;发行人&quot;,</span><br><span class="line">  &quot;exp&quot;：&quot;到期时间&quot;,</span><br><span class="line">  &quot;sub&quot;：&quot;主题&quot;,</span><br><span class="line">  &quot;aud&quot;：&quot;用户&quot;,</span><br><span class="line">  &quot;nbf&quot;：&quot;在此之前不可用&quot;,</span><br><span class="line">  &quot;iat&quot;：&quot;发布时间&quot;,</span><br><span class="line">  &quot;jti&quot;：&quot;JWT ID用于标识该JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了以上七个 JWT 定义的默认的字段外，还可自定义字段。 同样使用 base64 算法转换成字符串后即为 JWT 的 payload 部分。</p>
<p>Signature 是签名部分，对 header 和 payload 通过指定的算法加密后生成，在加密时指定一个 密钥（secret）， 该密钥存储在服务器中不得向用户公开。</p>
<p>以上三部分分别计算出后，使用 <code>.</code> 号分隔组合成的字符串即为 JWT token。</p>
<h3 id="如何防止-token-冒充"><a href="#如何防止-token-冒充" class="headerlink" title="如何防止 token 冒充"></a>如何防止 token 冒充</h3><p>客户端在接收到服务端返回的 token 后，一般把 token 存在浏览器 local storage 或者其他存储中，那么如果有人复制了这个 token，拷贝到另一个客户端使用，该怎么防止这种情况呢？</p>
<p>为了防止 token 冒充，服务端在生成 token 时使用 UserAgent 作为干扰码，不同的客户端干扰码不一样，那么直接将 token 拷贝到另一个客户端使用则无法验证成功，在一定程度上起到了防冒充的作用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/16/基于Token的身份验证方案/" data-id="ck6nisdb2000bf0uo3bj3e65p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/02/15/浏览器知识总结/">浏览器知识总结</a>
          </li>
        
          <li>
            <a href="/2019/09/27/Canvas绘制图形/">Canvas绘制图形</a>
          </li>
        
          <li>
            <a href="/2019/09/06/Vue源码学习之三/">Vue源码学习之三</a>
          </li>
        
          <li>
            <a href="/2019/09/06/Vue源码中知识点总结/">Vue源码中知识点总结</a>
          </li>
        
          <li>
            <a href="/2019/08/23/Vue源码学习之二/">Vue源码学习之二</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Rin&#39;s blog<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>